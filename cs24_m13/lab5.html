<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/public/variant-multi.css" title="Variant Multi" media="all" />
    <link rel="stylesheet" type="text/css" href="/public/monokai.sublime.css" />
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
    <title>Lab 5 &raquo; CS24 Summer 2013</title>
  </head>
  <body>
    <div id="container980">
<div id="header">
  <h1><a href="/cs24_m13/">Computer Science 24, Summer 2013</a></h1>
  <h2>Problem Solving with Computers II</h2>
</div>

<div id="menu">
  <ul>
    <li><a href="/cs24_m13/schedule">lecture schedule</a></li>
    <li><a href="/cs24_m13/submission">submission instructions</a></li>
  </ul>
</div>

<div id="main">
  <div id="sidebar">
    <div class="sidebarbox">
      <h2>People &amp; Office Hours</h2>
      <ul>
        <li><strong>Instructor</strong>: Bryce Boe
          (<a href="/">web</a>, <a href="mailto:bboe@cs.ucsb.edu">email</a>)
          <ul>
            <li>Tuesday, 14:15 - 15:15 in GSL</li>
            <li>Thursday, 11:15 - 12:15 in GSL</li>
          </ul>
        </li>
        <li><strong>TA</strong>: Jane Iedemska
          (<a href="mailto:jane@iedemska.com">email</a>)
          <ul>
            <li>Wednesday, 11:30 - 12:30 in Phelps 1413</li>
            <li>Thursday, 14:30 - 15:30 in Phelps 1413</li>
          </ul>
        </li>
      </ul>
    </div>

    <div class="sidebarbox">
      <h2>Deadlines</h2>
      <h3>All deadlines are at 23:59:59 on the due date.</h3>
      <ul>
        <li>2013/06/25 -- <a href="/cs24_m13/hw1">Homework 1</a></li>
        <li>2013/06/26 -- <a href="/cs24_m13/lab1">Lab 1</a></li>
        <li>2013/06/28 -- Course Drop with Refund</li>
        <li>2013/07/03 -- <a href="/cs24_m13/lab2">Lab 2</a></li>
        <li>2013/07/10 -- <a href="/cs24_m13/lab3">Lab 3</a></li>
        <li>2013/07/16 -- <a href="/cs24_m13/proj1">Project 1</a></li>
        <li>2013/07/17 -- <a href="/cs24_m13/lab4">Lab 4</a></li>
        <li>2013/08/01 -- <a href="/cs24_m13/lab5">Lab 5</a></li>
        <li>2013/08/07 -- <a href="/cs24_m13/lab6">Lab 6</a></li>
        <li>2013/08/10 -- <a href="/cs24_m13/proj2">Project 2 (Part 1)</a></li>
        <li>2013/08/14 -- <a href="/cs24_m13/lab7">Lab 7</a></li>
        <li>2013/08/17 -- <a href="/cs24_m13/proj2#part-2">Project 2 (Part 2)</a></li>
        <li>2013/08/21 -- <a href="/cs24_m13/lab8">Lab 8</a></li>
        <li>2013/08/30 -- <a href="/cs24_m13/proj3">Project 3</a></li>
      </ul>
    </div>
  </div>

  <div id="content">
<h2 id="lab-5-binary-search-tree-traversals">Lab 5: Binary Search Tree traversals</h2>

<h3 id="deadline-note">Deadline Note</h3>

<p>This lab is a bit more complex than some of the previous labs, thus you will
have until Thursday (2013/08/01) just before midnight (23:59:59) to complete
this lab.</p>

<h3 id="goals-for-this-lab">Goals for this lab</h3>

<p>By the time you have completed this lab, you should</p>

<ul>
  <li>learn about tree ADT</li>
  <li>implement your own Binary Search Tree ADT</li>
  <li>get familiar with using Stack and Queue ADT</li>
  <li>implement depth first search and breadth first search traversals</li>
</ul>

<p>The purpose of this lab is for you to get familiar with the tree ADT. A tree is
another basic abstract data type, which is widely used in computer
science. Because of the tree-like structure, there are multiple ways to
traverse data in a tree.  In this lab you will get familiar with and implement
two frequently used traversal operations: depth first search and breadth first
search.</p>

<h3 id="lab-pairing">Lab pairing</h3>

<p>For this lab you may work with a partner. Please, team up with the same person
you were working on the previous labs. When working with a partner, I strongly
encourage you follow the pair programming method of working together.</p>

<h3 id="lab-preparation">Lab preparation</h3>

<p>After logging in, create the directory for this lab:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> cs24/lab5
</code></pre></div></div>

<p>Change into the lab2 directory and copy the files you will need for this lab:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>cs24/lab5
<span class="nb">cp</span> ~bboe/public_html/cs24_m13/code/lab5/<span class="k">*</span> <span class="nb">.</span>
</code></pre></div></div>

<p>Open up README.txt with your favorite text editor and be sure to add your and
your partner’s name so that you both receive credit.</p>

<h3 id="trees-and-binary-search-trees">Trees and Binary Search Trees</h3>

<h4 id="trees">Trees</h4>

<p>A tree, in general is a data structure that, similar to a List, consists of
nodes with data and, this time, one or more pointers to other nodes. However, a
tree structure has an important requirement: no two pointers point to the same
node. This property is important, because tree must not have any loops.  From
the requirement it follows that each node may have only one parent (the node,
that is pointing to it), except for the very top one, which is called root. The
root has no parents, (similar to the head node in the List).  Nodes that don’t
have any children (no nodes pointed to) are called leaf nodes.  (Similar to the
tail node in the List).  More about the trees are on the <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">wiki
page</a>.</p>

<h4 id="binary-trees-binary-search-trees">Binary Trees, Binary Search Trees</h4>

<p>There are special type of trees called Binary Trees. Each of its nodes must
have no more than two children, usually distinguished as left and right. Among
the Binary Trees there are Binary Search Trees, for which there are additional
requirements, enforcing data in the tree to be sorted in some way.  First of
all, there must be no duplicate nodes in the tree (nodes with the same data
value) [for this lab you needn’t enforce this requirement].  Secondly, for
every node its left subtree (a tree that has its left child as a root) should
consist only of nodes with keys less than its key.  Additionally, for every
node its right subtree (a tree that has its right child as a root) should
consist only of nodes with keys greater than its key.  Finally, left and right
subtrees should also be BST themselves.  More on
<a href="https://en.wikipedia.org/wiki/Binary_search_tree">BSTs</a>. Below is an example
BST created when inserting the following integers: 5, 3, 7, 4, 2, 6, 8</p>

<p>Insert the 5:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
</code></pre></div></div>

<p>Insert the 3:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/
  3
</code></pre></div></div>

<p>Insert the 7:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/ \-
  3     7
</code></pre></div></div>

<p>Insert the 4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/ \-
  3     7
   \
    4
</code></pre></div></div>

<p>Insert the 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/ \-
  3     7
 / \
2   4
</code></pre></div></div>

<p>Insert the 6:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/ \-
  3     7
 / \   /
2   4 6
</code></pre></div></div>

<p>And finally, insert the 8:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     5
   -/ \-
  3     7
 / \   / \
2   4 6   8
</code></pre></div></div>

<h4 id="inserting-and-searching-in-bst">Inserting and searching in BST</h4>

<p>Since the data in BST is already presorted, it has advantage in search
operation over the List.  The search algorithm itself is very easy. You start
at the root node and compare its data with one you are looking for. If it
matches, you return true. When it does not match and node’s data is greater
than what you are searching for you traverse down the right child (why?). If
the node’s data is less than what you are searching for you traverse down the
left child (why?). This process is repeated until a match is found, or there
are no future nodes to traverse on the path.</p>

<p>When inserting a node in BST it is important that the new tree still has
original properties.  Therefore, it is important to select proper position for
a new node. The insertion algorithm is similar to search, for except when we
will reach a NULL pointer, we create a node and insert it in that position.</p>

<h4 id="templates-in-c">Templates in C++</h4>

<p>Thus far we have discussed abstract data values in the BST node without
mentioning the type we want to store specifically. In theory, BST nodes can
containing data of any type: integers, chars, strings, etc. But in C++ , when
you declare a node class, you must specify the data type in the very
beginning. If later we want to have the same structure with a different data
type, we will have to duplicate the code and only change the type.  We will
have to keep adding code for every new type we want to use. This is very
inefficient.  To avoid this routine C++ provides templates. Templates allow you
to create functions and classes with a generic type.  The type is then passed
as template parameter to the newly created function or class. Here is an
example.</p>

<p>Creating a template class:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">Node</span><span class="p">{</span>
  <span class="nl">private:</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Creating an integer and char nodes:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">node_int</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">node_char</span><span class="p">(</span><span class="sc">'z'</span><span class="p">);</span>
</code></pre></div></div>

<p>More on <a href="https://www.cplusplus.com/doc/tutorial/templates/">templates</a>.</p>

<h3 id="creating-bst">Creating BST</h3>

<p>For this lab you are given a source file and your goal is to complete
functionality of BST class, that is declared in the <code class="language-plaintext highlighter-rouge">bst.cpp</code>.</p>

<p>Initially, when you create a BST, the constructor should create only a root
pointer equal to NULL (an empty tree).  If you want to grow your tree, you
should implement and use the <code class="language-plaintext highlighter-rouge">insert</code> method for creating and adding nodes to
the tree.</p>

<h3 id="breadth-first-search-vs-depth-first-search">Breadth First Search vs Depth First Search</h3>

<p>After you’ve created your BST, it is time to traverse it!  As you might notice,
there are multiple possibilities to traverse BST because at every step you have
an option to move to left child or to the right child or to the node on the
same level (same number of nodes away from the root as the current one).</p>

<p>Commonly, <strong>depth first search</strong> (traversal) is the one, where you consistently
move towards left or right children and when reached the leaf node go one level
up and move towards the child, you haven’t checked out (the right or left one,
correspondingly).  If you’ve checked out all of the children of this node, go
one level up.</p>

<p>For example, a depth first traversal of the above tree will output nodes in the
following order (this assumes you “visit” the left hand side before the right
hand side):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 3 2 4 7 6 8 
</code></pre></div></div>

<p>Your <code class="language-plaintext highlighter-rouge">stack_output</code> function output should match the above exactly (note that
there is trailing space before you output the terminal newline. More on
<a href="https://en.wikipedia.org/wiki/Depth-first_search">dfs</a>.</p>

<p>Depth first traversal of a tree can be conveniently implemented with the help
of stack. We initialize the stack with the root node, and then loop until the
stack is empty. The first step of the loop is to do “something” with the value
of the node we’re currently looking at (may be to output it in the case of
<code class="language-plaintext highlighter-rouge">stack_output</code>) and then we push both of its children (if they exist) on to the
stack (you have to figure out which order).</p>

<p><strong>Breadth first search</strong> (traversal) is the one where you consistently move to
the nodes on the same level from left to right or in opposite directions. For
example, a breadth first traversal of the above tree will output nodes in the
following order:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 3 7 2 4 6 8 
</code></pre></div></div>

<p>Your <code class="language-plaintext highlighter-rouge">queue_output</code> function output should match the above exactly (note that
there is trailing space before you output the terminal newline. More on
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">bfs</a>.</p>

<p>Conveniently, breadth first search can be implemented by using queues rather
than stacks in a manor similar to how depth first search was implemented
(replace push with enqueue and pop with dequeue).</p>

<p>For the lab, there are two methods you have to implement: <code class="language-plaintext highlighter-rouge">stack_output</code> and
<code class="language-plaintext highlighter-rouge">queue_output</code> which correspond to dfs and bfs.</p>

<h3 id="hints">Hints</h3>

<h4 id="declaring-the-stack-and-queue">Declaring the Stack and Queue</h4>

<p>To implement <code class="language-plaintext highlighter-rouge">queue_output</code> and <code class="language-plaintext highlighter-rouge">stack_output</code> you need to respectively declare
both a templated version of the Stack class, and one of the Queue class. If the
Stack, or Queue needed to store integers, you could declare them like:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stack_variable_name</span><span class="p">;</span>
<span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue_variable_name</span><span class="p">;</span>
</code></pre></div></div>

<p>However, you want to store a pointer to the proper tree node type,
<code class="language-plaintext highlighter-rouge">BinaryNode</code>. To make things slightly more confusing, the BinaryNode type is
also templated so you need to specify what type the BinaryNode should be. If
you knew for certain the BinaryNode is to store a character, then you might
declare the Stack and Queue like:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stack</span><span class="o">&lt;</span><span class="n">BinaryNode</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*&gt;</span> <span class="n">char_stack</span><span class="p">;</span>
<span class="n">Queue</span><span class="o">&lt;</span><span class="n">BinaryNode</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*&gt;</span> <span class="n">char_queue</span><span class="p">;</span>
</code></pre></div></div>

<p>However, your BST implementation is templated so it should work with whatever
type the <em>user</em> of your program uses. That’s where the magic <code class="language-plaintext highlighter-rouge">T</code> variable as
declared in the line <code class="language-plaintext highlighter-rouge">template &lt;class T&gt;</code> comes in handy. <code class="language-plaintext highlighter-rouge">T</code> specifies what
type the class holds so you can simply replace <code class="language-plaintext highlighter-rouge">char</code> in our previous example
with <code class="language-plaintext highlighter-rouge">T</code> like the following in order to declare the Stack and Queue for the
respective functions:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stack</span><span class="o">&lt;</span><span class="n">BinaryNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">stack</span><span class="p">;</span>
<span class="n">Queue</span><span class="o">&lt;</span><span class="n">BinaryNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">queue</span><span class="p">;</span>
</code></pre></div></div>

<p>As a quick note, if you simply wanted to store copies and not pointers to
BinaryNodes in the Stack (for example) you would need to add a space between
the two closing <code class="language-plaintext highlighter-rouge">&gt;</code> characters as per the C++ syntax rules (<code class="language-plaintext highlighter-rouge">&gt;&gt;</code> is the
shift-right operator):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stack</span><span class="o">&lt;</span><span class="n">BinaryNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">stack</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="submitting-the-project">Submitting the project</h3>

<p>Only one person in a group need submit the project. If both members of a group
submit we will only score the last submission made between the two group
members. Please review the
<a href="/cs24_m13/submission">submission instructions</a> as needed. On the submission site
you will find the command you need to use to submit the project. Note that you
may resubmit this project as many times as necessary up until the deadline.</p>

  </div>
  <div class="clear">&nbsp;</div>
</div>

      <div id="credits">
        <p><span class="small">Template design by <a href="https://andreasviklund.com/">Andreas Viklund</a></span></p>
      </div>
    </div>
  </body>
</html>
